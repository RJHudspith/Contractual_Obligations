/*
    Copyright 2013-2018 Renwick James Hudspith

    This file (CERN.c) is part of GLU.

    GLU is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GLU is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GLU.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
   @file CERN.c
   @brief code to read and write CERN configs generated by openQCD

   bizarrely their geometry is
   t,x,y,z which makes little sense to me. I imagine there is a very good reason
   for this.... Probably.
   
   @warning these aren't #NC or #ND generic. Just for SU3
 */
#include "common.h"

#include "geometry.h"      // gen_site()
#include "GLU_bswap.h"     // byte swapping arrays
#include "plaqs_links.h"   // compute the plaquette

// read a CERN gauge field
int
read_CLS_field( struct site *__restrict lat , 
		FILE *__restrict in , 
		uint32_t *chksum )
{
  const size_t Nelements = NCNC ;
  const size_t PM = 2 ; // +/-
  const size_t Complex = 2 ; // double complex

  const size_t stride = PM * Complex * Nelements * ND ;
  // these guys also seem to save only in double, making things easy
  double *uind = malloc( stride * sizeof( double ) ) ; 

  uint32_t k = 0 ;
  size_t x, y,z,t ;
  for( t = 0 ; t < Latt.dims[ND-1] ; t++ ) {
    for( x = 0 ; x < Latt.dims[0] ; x++ ) {
      for( y = 0 ; y < Latt.dims[1] ; y++ ) {
	for( z = 0 ; z < Latt.dims[2] ; z++ ) {
    
	  if( (x+y+z+t)%2 ) {
	    
	    int X[ ND ] = { (int)x , (int)y , (int)z , (int)t } ;

	    const size_t idx = gen_site( X ) ;
	    
	    if( fread( uind , sizeof( double ) , stride , in ) != stride ) {
	      fprintf( stderr , "File read error.. Leaving \n " ) ;
	      free( uind ) ;
	      return FAILURE ;
	    }
	    if( WORDS_BIGENDIAN ) {
	      bswap_64( stride , uind ) ; 
	    }
      
	    size_t mu , j , a = 0 ;
	    size_t shift = lat[idx].back[ND-1] ;
	    // t first
	    for( j = 0 ; j < NCNC ; j++ ) {
	      lat[idx].O[ND-1][j] = uind[a] + I * uind[a + 1] ;
	      a += 2 ;
	    }
	    for( j = 0 ; j < NCNC ; j++ ) {
	      lat[shift].O[ND-1][j] = uind[a] + I * uind[a + 1] ;
	      a += 2 ;
	    }
	    // then the others (xyz)?
	    for( mu = 0 ;  mu < ND - 1 ; mu++ ) {
	      for( j = 0 ; j < NCNC ; j++ ) {
		lat[idx].O[mu][j] = uind[a] + I * uind[a + 1] ;
		a += 2 ;
	      }
	      size_t shift = lat[idx].back[mu] ;
	      for( j = 0 ; j < NCNC ; j++ ) {
		lat[shift].O[mu][j] = uind[a] + I * uind[a + 1] ;
		a += 2 ;
	      }
	    }
	  }
	  
	}}}}
  
  //latt_reunitU( lat ) ;
  
  *chksum = k ;
  free( uind ) ;
  return SUCCESS ; 
}


